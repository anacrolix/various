#!/usr/bin/env python

import logging
import os.path
import pdb
from errno import *
from stat import *

import fuse

import clfs
from clfs import ClfsError


fuse.fuse_python_api = (0, 2)


class FuseClfs(fuse.Fuse):

    def opendir(self, path):
        return 0

    def open(self, path, flags):
        return 0

    def readdir(self, path, offset, handle=None):
        yield fuse.Direntry(".")
        yield fuse.Direntry("..")
        parent_dirent = self.fs.get_dir_entry(path)
        for dirent in self.fs.read_directory(parent_dirent["inode"]):
            yield fuse.Direntry(
                    name=dirent["name"].rstrip("\0"),
                    ino=dirent["inode"],)

    def getattr(self, path):
        #pdb.set_trace()
        try:
            dirent = self.fs.get_dir_entry(path)
        except ClfsError as error:
            return -error.errno
        inode = self.fs.get_inode_struct(dirent["inode"])
        mode = {
                clfs.TYPE_DIRECTORY: S_IFDIR,
                clfs.TYPE_REGULAR_FILE: S_IFREG,
            }[inode["type"]]
        return fuse.Stat(
                st_mode=mode|0007,
                st_nlink=inode["links"],
                st_size=inode["size"])

    def mkdir(self, path, mode):
        return self.mknod(path, mode | S_IFDIR, 0)

    def main(self, *pargs, **kwargs):
        assert not hasattr(self, "fs")
        try:
            self.fs = clfs.Clfs(self.cmdline[1][0])
        except:
            pass
        fuse.Fuse.main(self, *pargs, **kwargs)

    def statfs(self):
        blocks = free = 0
        for cn in self.fs.iter_allocation_table():
            blocks += 1
            if cn == clfs.CLUSTER_FREE:
                free += 1
        return fuse.StatVfs(
                f_bsize=self.fs.cluster_size,
                f_namemax=clfs.CLFS_NAMEMAX,
                f_blocks=blocks,
                f_bfree=free,
                f_bavail=free)

    #def create(self, path, mode, rdev):
    #    return -EOPNOTSUPP

    def mknod(self, path, mode, rdev):
        if S_ISREG(mode):
            type = clfs.TYPE_REGULAR_FILE
        elif S_ISDIR(mode):
            type = clfs.TYPE_DIRECTORY
        else:
            return -EPERM
        assert rdev == 0, rdev
        self.fs.create_node(path, type)
        #return 0

    def write(self, path, buf, offset, fh=None):
        dirent = self.fs.get_dir_entry(path)
        #pdb.set_trace()
        bytes_written = self.fs.write_inode_data(dirent["inode"], offset, buf)
        assert bytes_written == len(buf), bytes_written
        # stupid python-fuse requires int, long generates EINVAL
        return int(bytes_written)

    def read(self, path, size, offset, fh=None):
        dirent = self.fs.get_dir_entry(path)
        return self.fs.read_inode_data(dirent["inode"], offset, size)

    #def ftruncate(self, path, size, fh):
    #    dirent = self.fs.get_dir_entry(path)
    #    self.fs.truncate_file(dirent)
    #    return 0

    def truncate(self, path, size):
        dirent = self.fs.get_dir_entry(path)
        self.fs.truncate_file(dirent["inode"], size)
        return 0

    #def utime(self, times):
        #return utimens(times)

    #def utimens(self, times):
        #return 0

    #def chmod(self, path, mode):
        #return 0

    #def chown(self, path, uid, gid):
        #return 0

    def flush(self, path, fh=None):
        self.fs.f.flush()

    def access(self, path, flags):
        return 0
    #

def main():
    logging.basicConfig(level=logging.DEBUG)
    server = FuseClfs()
    server.parse(errex=1)
    #server.cmdline
    server.multithreaded = False
    server.main()

if __name__ == '__main__':
    main()
