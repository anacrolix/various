#!/usr/bin/env python

from errno import *
from stat import *
from os import strerror
from sys import argv
import logging
import os.path

from fuse import FUSE, Operations, LoggingMixIn
from clfs import Clfs, ClfsError
import clfs


class FuseClfs(
            #LoggingMixIn,
            Operations,
        ):

    def __call__(self, op, path, *args):
        # this code is based on fuse.LoggingMixIn.__call__
        logger = logging.getLogger("fusepy")
        logger.debug("-> %s %s %r", op, path, args)
        #print '->', op, path, repr(args)
        # perhaps this should be "[Unhandled exception]"
        ret = '[Unhandled Exception]'
        try:
            ret = getattr(self, op)(path, *args)
            return ret
        # this catches ClfsError as its derived from OSError
        except OSError, e:
            ret = str(e)
            raise
        finally:
            #print '<-', op, repr(ret)
            logger.debug("<- %s %r", op, ret)

    def __init__(self, device):
        #self.log =
        self.fs = Clfs(device)

    create = None

    def _readdir(self, path, offset, handle=None):
        yield "."
        yield ".."
        parent_dirent = self.fs.get_dir_entry(path)
        for dirent in self.fs.read_directory(parent_dirent["ino"]):
            yield (
                dirent["name"].rstrip("\0"),
                dict(st_inode=dirent["ino"]),
                0)

    def readdir(self, *args, **kwargs):
        return tuple(self._readdir(*args, **kwargs))

    def getattr(self, path, fh=None):
        assert fh is None, fh
        dirent = self.fs.get_dir_entry(path)
        inode = self.fs.get_inode_struct(dirent["ino"])
        return dict(
                st_mode=inode["mode"],
                st_nlink=inode["nlink"],
                st_size=inode["size"],
                **inode.get_st_times())

    def mkdir(self, path, mode):
        return self.mknod(path, mode | S_IFDIR, 0)

    def main(self, *pargs, **kwargs):
        assert not hasattr(self, "fs")
        try:
            self.fs = clfs.Clfs(self.cmdline[1][0])
        except:
            pass
        fuse.Fuse.main(self, *pargs, **kwargs)

    def statfs(self):
        blocks = free = 0
        for cn in self.fs.iter_allocation_table():
            blocks += 1
            if cn == clfs.CLUSTER_FREE:
                free += 1
        return fuse.StatVfs(
                f_bsize=self.fs.cluster_size,
                f_namemax=clfs.CLFS_NAMEMAX,
                f_blocks=blocks,
                f_bfree=free,
                f_bavail=free)

    def mknod(self, path, mode, rdev):
        self.fs.create_node(path, mode)

    def write(self, path, buf, offset, fh=None):
        dirent = self.fs.get_dir_entry(path)
        bytes_written = self.fs.write_inode_data(dirent["ino"], offset, buf)
        assert bytes_written == len(buf), bytes_written
        # stupid python-fuse requires int, long generates EINVAL
        return int(bytes_written)

    def read(self, path, size, offset, fh=None):
        dirent = self.fs.get_dir_entry(path)
        return self.fs.read_inode_data(dirent["inode"], offset, size)

    def truncate(self, path, size):
        dirent = self.fs.get_dir_entry(path)
        self.fs.truncate_file(dirent["ino"], size)


def main():
    logging.basicConfig(level=logging.DEBUG)
    FUSE(FuseClfs(argv[1]), argv[2], foreground=True, nothreads=True)

if __name__ == '__main__':
    main()
