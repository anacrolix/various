#!/usr/bin/env python

from errno import *
from stat import *
from os import strerror
from sys import argv
import logging
import os.path

from fuse import FUSE, Operations, LoggingMixIn
from clfs import Clfs, ClfsError
import clfs

class FuseClfs(
            #LoggingMixIn,
            Operations,
        ):

    def __call__(self, op, path, *args):
        logger = logging.getLogger("fusepy")
        logger.debug("-> %s %s %r", op, path, args)
        #print '->', op, path, repr(args)
        ret = '[Unknown Error]'
        try:
            ret = getattr(self, op)(path, *args)
            return ret
        except OSError, e:
            ret = str(e)
            raise
        finally:
            #print '<-', op, repr(ret)
            logger.debug("<- %s %r", op, ret)

    def __init__(self, device):
        #self.log =
        self.fs = Clfs(device)

    create = None

    def readdir(self, path, offset, handle=None):
        yield "."
        yield ".."
        parent_dirent = self.fs.get_dir_entry(path)
        for dirent in self.fs.read_directory(parent_dirent["inode"]):
            yield (
                dirent["name"].rstrip("\0"),
                dict(st_inode=dirent["inode"]),
                0)

    def getattr(self, path, fh=None):
        assert fh is None, fh
        dirent = self.fs.get_dir_entry(path)
        inode = self.fs.get_inode_struct(dirent["inode"])
        mode = {
                clfs.TYPE_DIRECTORY: S_IFDIR,
                clfs.TYPE_REGULAR_FILE: S_IFREG,
            }[inode["type"]]
        return dict(
                st_mode=mode|0007,
                st_nlink=inode["links"],
                st_size=inode["size"])

    def mkdir(self, path, mode):
        return self.mknod(path, mode | S_IFDIR, 0)

    def main(self, *pargs, **kwargs):
        assert not hasattr(self, "fs")
        try:
            self.fs = clfs.Clfs(self.cmdline[1][0])
        except:
            pass
        fuse.Fuse.main(self, *pargs, **kwargs)

    def statfs(self):
        blocks = free = 0
        for cn in self.fs.iter_allocation_table():
            blocks += 1
            if cn == clfs.CLUSTER_FREE:
                free += 1
        return fuse.StatVfs(
                f_bsize=self.fs.cluster_size,
                f_namemax=clfs.CLFS_NAMEMAX,
                f_blocks=blocks,
                f_bfree=free,
                f_bavail=free)

    def mknod(self, path, mode, rdev):
        if S_ISREG(mode):
            type = clfs.TYPE_REGULAR_FILE
        elif S_ISDIR(mode):
            type = clfs.TYPE_DIRECTORY
        else:
            return -EPERM
        assert rdev == 0, rdev
        self.fs.create_node(path, type)
        #return 0

    def write(self, path, buf, offset, fh=None):
        dirent = self.fs.get_dir_entry(path)
        #pdb.set_trace()
        bytes_written = self.fs.write_inode_data(dirent["inode"], offset, buf)
        assert bytes_written == len(buf), bytes_written
        # stupid python-fuse requires int, long generates EINVAL
        return int(bytes_written)

    def read(self, path, size, offset, fh=None):
        dirent = self.fs.get_dir_entry(path)
        return self.fs.read_inode_data(dirent["inode"], offset, size)

    def truncate(self, path, size):
        dirent = self.fs.get_dir_entry(path)
        self.fs.truncate_file(dirent["inode"], size)
        return 0

    #def utimens(self, path, atime, mtime):
        #logging.debug("Fuse utimens(%r, %r, %r)", path, atime, mtime)
        #return 0


def main():
    logging.basicConfig(level=logging.DEBUG)
    FUSE(FuseClfs(argv[1]), argv[2], debug=True, nothreads=True)

if __name__ == '__main__':
    main()
