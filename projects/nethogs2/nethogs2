#!/usr/bin/env python

# this must go first, we require true division
from __future__ import division

# constants for tweaking by packagers
PROGNAME = "Nethogs2"
VERSION = "0.1-dev"

from common import *

import proctab
import pktanal

class DeviceCapture(object):
    import pcap # here to force the interface to be pcap free
    def __init__(self, name, promisc=False):
        self.name = name
        self.handle = self.pcap.pcapObject()

        # configure the pcap device
        logging.info("Opening device %s" % repr(name))
        try:
            # snaplen must be long enough for all headers, and short enough that packets aren't dropped
            self.handle.open_live(name, 150, promisc, 0)
        except Exception as e:
            sys.exit("Error opening %s: %s" % (name, e))
        self.handle.setnonblock(True)

        self.addresses = set()
        for name, desc, addrs, flags in self.pcap.findalldevs():
            if name == self.name:
                self.addresses.update(*map(lambda x: (x[0], x[2]), addrs))
    def dispatch(self, count, callback):
        def callback_wrapper(pktlen, data, ts):
            callback(pktlen, data, ts, self)
        print "read %d packets" % self.handle.dispatch(count, callback_wrapper)
    @property
    def datalink(self):
        """Returns the datalink type as a string"""
        return {
                self.pcap.DLT_EN10MB: 'ethernet',
            }[self.handle.datalink()]
    def stats(self):
        """Returns a tuple containing the number of packets transited on the network, and the number of packets dropped by the driver"""
        return self.handle.stats()[0:2]

def normalize_data_quantity(quantity, multiple=1024):
    assert (7 / 3) != 2 # ensure true division is in effect
    SUFFIXES = ["B"] + [i + {1000: "B", 1024: "iB"}[multiple] for i in "KMGTPEZY"]
    for suffix in SUFFIXES:
        if quantity < multiple:
            break
        else:
            quantity /= multiple
    return ("%5d" if quantity.is_integer() else "%5.1f") % quantity, suffix

NetworkHog = collections.namedtuple("NetworkHog", ["pid", "cmdline", "user", "device"])

class ProcessTraffic(dict):
    def __getitem__(self, key):
        return self.setdefault(key, [0, 0])
    def __iadd__(self, other):
        for proc, rates in other.iteritems():
            assert len(rates) == 2
            self[proc][:] = map(operator.add, self[proc], rates)
        return self
    def __itruediv__(self, other):
        for rates in self.itervalues():
            rates[:] = map(lambda x: x / other, rates)
        return self

def dispatch_traffic_per_process_per_epoch(devcaps, proctable):
    """Return a dictionary mapping an integer epoch to the recorded per process send and receive byte counts for that second."""
    # {process: (sent, received)}
    trafinfo = {}
    def packet_callback(pktlen, data, ts, devcap):
        # (source, destination)
        conn = pktanal.analyse_packet(data, devcap.datalink)
        logging.debug("Analyse packet: %s, length=%d" % (conn, pktlen))
        #logging.debug("Analysed packet: %s" % str(conn))
        if conn == None:
            return
        outgoing, procinfo = proctable.netconn_to_procinfo(conn, devcap.addresses)
        #procinfo = proctable.
        nethog = NetworkHog(device=devcap.name, **procinfo._asdict())
        trafinfo.setdefault(int(ts), ProcessTraffic())[nethog][0 if outgoing else 1] += pktlen
    for dc in devcaps:
        dc.dispatch(-1, packet_callback)
        # don't allow any packets to drop, this should be moved further down the stack
        assert dc.stats()[1] == 0
    return trafinfo

def _redraw_screen(win, trafinfo):
    win.clear()
    win.addstr(0, 0, "%s v. %s" % (PROGNAME, VERSION))
    # cols determination could be broken out here, to allow dynamically resizing columns
    COLS = ("pid", 5), ("user", 8), ("program", 33), ("dev", 7), ("sent", 11), ("received", 11)
    LINEFMT = " ".join(["{{{0}:{1}.{1}}}".format(colhdr, width) for colhdr, width in COLS])
    win.addstr(2, 0, LINEFMT.format(**dict([(a[0], a[0].upper()) for a in COLS])), curses.A_REVERSE)
    def keyfunc(x):
        """Sort by the sum of incoming and outgoing traffic"""
        return sum(x[1])
    def rate_to_str(byterate):
        return "%s%s/s" % normalize_data_quantity(byterate)
    linenr = 3
    for nethog, traf in sorted(trafinfo.iteritems(), key=keyfunc, reverse=True):
        progargs = nethog.cmdline.split("\x00")
        program = " ".join([os.path.basename(progargs[0])] + progargs[1:])
        line = LINEFMT.format(
                pid=(str(nethog.pid) if nethog.pid != None else ""),
                program=program,
                sent=rate_to_str(traf[0]),
                received=rate_to_str(traf[1]),
                user=nethog.user,
                dev=nethog.device)
        #logging.debug(repr(line))
        win.addstr(linenr, 0, line)
        linenr += 1
        #win.addstr(str((proc, traf)) + "\n")
    win.refresh()

def transform(unaries, iterable):
    return map(lambda a, b: a(b) if a is not None else b, unaries, iterable)

class Nethogs2(object):
    def __init__(self, intervals, devnames):
        self.devcaps = []
        for dn in devnames:
            dc = DeviceCapture(dn)
            self.devcaps.append(dc)
        self.proctable = proctab.ProcTable()
        self.refresh = True
        self.trafinfo = {} # {epoch: {NetworkHog: [sent, received]}}
        assert signal.SIG_DFL == signal.signal(signal.SIGALRM, self.alarm_callback)
        # fire this ASAP, can't use seconds=0 because this disables it
        assert (0, 0) == signal.setitimer(signal.ITIMER_REAL, intervals['dispatch'], intervals['dispatch'])
        self.smoothing = intervals['smoothing']
        self.run()
    def main_loop(self):
        self.redraw_screen(time.time())
        while True:
            while self.refresh:
                self.refresh = False
                self.do_refresh()
            signal.pause()
    def alarm_callback(self, *args):
        logging.debug("Alarm triggered at %f" % (time.time(),))
        self.refresh = True
    def run(self):
        print "Starting user interface..."
        def curses_wrapper(stdscr):
            self.stdscr = stdscr
            self.main_loop()
        curses.wrapper(curses_wrapper)
    def redraw_screen(self, cursec):
        meantraf = ProcessTraffic()
        showticks = range(cursec - 1, cursec - 1 - self.smoothing, -1)
        assert len(showticks) == self.smoothing
        for tick in showticks:
            if tick in self.trafinfo:
                meantraf += self.trafinfo[tick]
        meantraf /= self.smoothing
        _redraw_screen(self.stdscr, meantraf)
    def do_refresh(self):
        updstart = int(time.time())
        self.proctable.update_table()
        newinfo = dispatch_traffic_per_process_per_epoch(self.devcaps, self.proctable)
        for epoch, info in newinfo.iteritems():
            self.trafinfo.setdefault(epoch, ProcessTraffic())
            self.trafinfo[epoch] += info
        self.redraw_screen(updstart)

if __name__ == "__main__":
    parser = optparse.OptionParser(version=VERSION, usage="%prog [options] DEVICES...")
    parser.add_option("-d", "--dispatch", help="seconds between packet dispatches and proc polling", type='float', default=0.25)
    parser.add_option("-r", "--refresh", help="time between display updates in seconds", type='float', default=2.0)
    parser.add_option("-s", "--smoothing", help="average the traffic over this many preceding seconds", type='int', default=3)
    parser.add_option("--unittests", help="run the unit tests", action='store_true')
    parser.disable_interspersed_args()
    options, posargs = parser.parse_args()

    # this has to go before any use of logging
    logging.basicConfig(filename="nethogs2.log", filemode="w", level=logging.DEBUG,
            format="%(levelname)s:%(filename)s(%(lineno)d):%(message)s")

    logging.debug("Options " + repr(options))
    logging.debug("Positional arguments " + repr(posargs))
    if options.unittests:
        unittest.main(argv=(sys.argv[0:1] + posargs))
    else:
        logging.basicConfig(filename="nethogs2.log", filemode="w", level=logging.DEBUG)
        if len(posargs) == 0:
            print "No device specified, defaulting to eth0"
        Nethogs2(dict(dispatch=options.dispatch, refresh=options.refresh, smoothing=options.smoothing), posargs or ("eth0",))
